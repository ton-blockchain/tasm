import {writeFileSync} from "node:fs"
import * as t from "@babel/types"
import type * as $ from "./instructions"
import type {Opcode} from "./instructions"
import {instructionList, pseudoInstructions} from "./instructions"
import generateTs from "@babel/generator"

const RUNTIME_QUALIFIER = t.identifier("c")
const TON_CORE_QUALIFIER = t.identifier("$")
// const INSTRUCTIONS_QUALIFIER = t.identifier("$inst")

const main = () => {
    writeFileSync(`${__dirname}/../runtime/walker.ts`, generate())
}

const generate = (): string => {
    const importRuntime = t.importDeclaration(
        [t.importNamespaceSpecifier(RUNTIME_QUALIFIER)],
        t.stringLiteral("./index"),
    )

    const importTonCore = t.importDeclaration(
        [t.importNamespaceSpecifier(TON_CORE_QUALIFIER)],
        t.stringLiteral("@ton/core"),
    )

    const argUnionType = t.exportNamedDeclaration(
        t.tsTypeAliasDeclaration(
            t.identifier("InstructionArg"),
            undefined,
            t.tsUnionType([
                // Number types
                createArgType("uint", t.tsNumberKeyword()),
                createArgType("int", t.tsNumberKeyword()),
                createArgType("refs", t.tsNumberKeyword()),
                createArgType("stack", t.tsNumberKeyword()),
                createArgType("control", t.tsNumberKeyword()),
                createArgType("plduzArg", t.tsNumberKeyword()),
                createArgType("tinyInt", t.tsNumberKeyword()),
                createArgType("runvmArg", t.tsNumberKeyword()),
                createArgType("minusOne", t.tsNumberKeyword()),
                createArgType("s1", t.tsNumberKeyword()),
                createArgType("setcpArg", t.tsNumberKeyword()),
                createArgType("hash", t.tsNumberKeyword()),
                // BigInt types
                createArgType("largeInt", t.tsBigIntKeyword()),
                // Special types
                createArgType(
                    "code",
                    t.tsTypeReference(
                        t.tsQualifiedName(RUNTIME_QUALIFIER, t.identifier("util.Code")),
                    ),
                ),
                createArgType(
                    "slice",
                    t.tsTypeReference(t.tsQualifiedName(TON_CORE_QUALIFIER, t.identifier("Slice"))),
                ),
                createArgType(
                    "debugstr",
                    t.tsTypeReference(t.tsQualifiedName(TON_CORE_QUALIFIER, t.identifier("Slice"))),
                ),
                createArgType(
                    "exoticCell",
                    t.tsTypeReference(t.tsQualifiedName(TON_CORE_QUALIFIER, t.identifier("Cell"))),
                ),
                createArgType(
                    "dictpush",
                    t.tsTypeReference(
                        t.tsQualifiedName(RUNTIME_QUALIFIER, t.identifier("util.Dict")),
                    ),
                ),
            ]),
        ),
    )

    function createArgType(argTypeName: string, valueType: t.TSType): t.TSTypeLiteral {
        return t.tsTypeLiteral([
            t.tsPropertySignature(
                t.identifier("$"),
                t.tsTypeAnnotation(t.tsLiteralType(t.stringLiteral(argTypeName))),
            ),
            t.tsPropertySignature(t.identifier("value"), t.tsTypeAnnotation(valueType)),
        ])
    }

    const walkerFunction = generateWalkerFunction(instructionList())

    const file = t.file(t.program([importRuntime, importTonCore, argUnionType, walkerFunction]))

    t.addComment(
        file,
        "leading",
        ` AUTOGENERATED, DO NOT EDIT, generated by ../generator/gen-walker.ts`,
        true,
    )

    return generateTs(file).code
}

function generateWalkerFunction(instructions: [string, Opcode][]): t.ExportNamedDeclaration {
    const nameIdent = t.identifier("walkInstructionArgs")

    const instrParam = t.identifier("instr")
    instrParam.typeAnnotation = t.tsTypeAnnotation(
        t.tsTypeReference(t.tsQualifiedName(RUNTIME_QUALIFIER, t.identifier("Instr"))),
    )

    const callbackParam = t.identifier("callback")
    callbackParam.typeAnnotation = t.tsTypeAnnotation(
        t.tsFunctionType(
            undefined,
            [
                t.identifier("instr"),
                t.identifier("arg"),
                t.identifier("argName"),
                t.identifier("argIndex"),
            ].map((param, index) => {
                switch (index) {
                    case 0: {
                        param.typeAnnotation = t.tsTypeAnnotation(
                            t.tsTypeReference(
                                t.tsQualifiedName(RUNTIME_QUALIFIER, t.identifier("Instr")),
                            ),
                        )
                        break
                    }
                    case 1: {
                        param.typeAnnotation = t.tsTypeAnnotation(
                            t.tsTypeReference(t.identifier("InstructionArg")),
                        )
                        break
                    }
                    case 2: {
                        param.typeAnnotation = t.tsTypeAnnotation(t.tsStringKeyword())
                        break
                    }
                    default: {
                        param.typeAnnotation = t.tsTypeAnnotation(t.tsNumberKeyword())
                    }
                }
                return param
            }),
            t.tsTypeAnnotation(t.tsVoidKeyword()),
        ),
    )

    const params = [instrParam, callbackParam]

    const cases = instructions.flatMap(([name, opcode]) => {
        if (pseudoInstructions.has(name)) {
            return []
        }

        const statements = generateWalkStatements(opcode.args)
        return [t.switchCase(t.stringLiteral(name), [...statements, t.returnStatement()])]
    })

    const body = t.blockStatement([
        t.switchStatement(t.memberExpression(t.identifier("instr"), t.identifier("$")), [
            ...cases,
            t.switchCase(undefined, []), // default case
        ]),
    ])

    return t.exportNamedDeclaration(
        t.variableDeclaration("const", [
            t.variableDeclarator(nameIdent, t.arrowFunctionExpression(params, body)),
        ]),
    )
}

function generateWalkStatements(args: $.args): t.Statement[] {
    switch (args.$) {
        case "simpleArgs":
            return generateSimpleArgsWalk(args.children)
        case "xchgArgs":
            return generateXchgArgsWalk()
        case "dictpush":
            return generateDictpushArgsWalk()
    }

    throw new Error("Unexpected arg type")
}

function generateSimpleArgsWalk(args: $.arg[]): t.Statement[] {
    return args.flatMap((arg, index) => {
        return generateArgWalk(arg, `arg${index}`, index)
    })
}

function generateXchgArgsWalk(): t.Statement[] {
    // XCHG has two stack arguments
    return [generateCallbackCall("stack", "arg0", 0), generateCallbackCall("stack", "arg1", 1)]
}

function generateDictpushArgsWalk(): t.Statement[] {
    // DICTPUSH has int and dict arguments
    return [generateCallbackCall("uint", "arg0", 0), generateCallbackCall("dictpush", "arg1", 1)]
}

function generateArgWalk(arg: $.arg, argName: string, argIndex: number): t.Statement[] {
    const argType = getArgTypeString(arg)
    return [generateCallbackCall(argType, argName, argIndex)]
}

function getArgTypeString(arg: $.arg): string {
    switch (arg.$) {
        case "int":
        case "uint":
        case "refs":
        case "stack":
        case "control":
        case "plduzArg":
        case "tinyInt":
        case "runvmArg":
        case "minusOne":
        case "s1":
        case "setcpArg":
        case "largeInt":
        case "hash":
        case "debugstr":
        case "slice":
        case "exoticCell":
            return arg.$
        case "codeSlice":
        case "refCodeSlice":
        case "inlineCodeSlice":
            return "code"
        case "delta":
            return getArgTypeString(arg.arg)
    }

    throw new Error(`Unexpected arg type: ${(arg as {$: string}).$}`)
}

function generateCallbackCall(
    argType: string,
    argName: string,
    argIndex: number,
): t.ExpressionStatement {
    return t.expressionStatement(
        t.callExpression(t.identifier("callback"), [
            t.identifier("instr"),
            t.objectExpression([
                t.objectProperty(t.identifier("$"), t.stringLiteral(argType)),
                t.objectProperty(
                    t.identifier("value"),
                    t.memberExpression(t.identifier("instr"), t.identifier(argName)),
                ),
            ]),
            t.stringLiteral(argName),
            t.numericLiteral(argIndex),
        ]),
    )
}

main()
