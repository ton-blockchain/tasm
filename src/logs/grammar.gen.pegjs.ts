// @generated by Peggy 5.0.3.
//
// https://peggyjs.org/

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck

class peg$SyntaxError extends SyntaxError {
    constructor(message, expected, found, location) {
        super(message)
        this.expected = expected
        this.found = found
        this.location = location
        this.name = "SyntaxError"
    }

    format(sources) {
        let str = "Error: " + this.message
        if (this.location) {
            let src = null
            const st = sources.find(s => s.source === this.location.source)
            if (st) {
                src = st.text.split(/\r\n|\n|\r/g)
            }
            const s = this.location.start
            const offset_s =
                this.location.source && typeof this.location.source.offset === "function"
                    ? this.location.source.offset(s)
                    : s
            const loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column
            if (src) {
                const e = this.location.end
                const filler = "".padEnd(offset_s.line.toString().length, " ")
                const line = src[s.line - 1]
                const last = s.line === e.line ? e.column : line.length + 1
                const hatLen = last - s.column || 1
                str +=
                    "\n --> " +
                    loc +
                    "\n" +
                    filler +
                    " |\n" +
                    offset_s.line +
                    " | " +
                    line +
                    "\n" +
                    filler +
                    " | " +
                    "".padEnd(s.column - 1, " ") +
                    "".padEnd(hatLen, "^")
            } else {
                str += "\n at " + loc
            }
        }
        return str
    }

    static buildMessage(expected, found) {
        function hex(ch) {
            return ch.codePointAt(0).toString(16).toUpperCase()
        }

        const nonPrintable = Object.prototype.hasOwnProperty.call(RegExp.prototype, "unicode")
            ? new RegExp("[\\p{C}\\p{Mn}\\p{Mc}]", "gu")
            : null
        function unicodeEscape(s) {
            if (nonPrintable) {
                return s.replace(nonPrintable, ch => "\\u{" + hex(ch) + "}")
            }
            return s
        }

        function literalEscape(s) {
            return unicodeEscape(
                s
                    .replace(/\\/g, "\\\\")
                    .replace(/"/g, '\\"')
                    .replace(/\0/g, "\\0")
                    .replace(/\t/g, "\\t")
                    .replace(/\n/g, "\\n")
                    .replace(/\r/g, "\\r")
                    .replace(/[\x00-\x0F]/g, ch => "\\x0" + hex(ch))
                    .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => "\\x" + hex(ch)),
            )
        }

        function classEscape(s) {
            return unicodeEscape(
                s
                    .replace(/\\/g, "\\\\")
                    .replace(/\]/g, "\\]")
                    .replace(/\^/g, "\\^")
                    .replace(/-/g, "\\-")
                    .replace(/\0/g, "\\0")
                    .replace(/\t/g, "\\t")
                    .replace(/\n/g, "\\n")
                    .replace(/\r/g, "\\r")
                    .replace(/[\x00-\x0F]/g, ch => "\\x0" + hex(ch))
                    .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => "\\x" + hex(ch)),
            )
        }

        const DESCRIBE_EXPECTATION_FNS = {
            literal(expectation) {
                return '"' + literalEscape(expectation.text) + '"'
            },

            class(expectation) {
                const escapedParts = expectation.parts.map(part =>
                    Array.isArray(part)
                        ? classEscape(part[0]) + "-" + classEscape(part[1])
                        : classEscape(part),
                )

                return (
                    "[" +
                    (expectation.inverted ? "^" : "") +
                    escapedParts.join("") +
                    "]" +
                    (expectation.unicode ? "u" : "")
                )
            },

            any() {
                return "any character"
            },

            end() {
                return "end of input"
            },

            other(expectation) {
                return expectation.description
            },
        }

        function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation)
        }

        function describeExpected(expected) {
            const descriptions = expected.map(describeExpectation)
            descriptions.sort()

            if (descriptions.length > 0) {
                let j = 1
                for (let i = 1; i < descriptions.length; i++) {
                    if (descriptions[i - 1] !== descriptions[i]) {
                        descriptions[j] = descriptions[i]
                        j++
                    }
                }
                descriptions.length = j
            }

            switch (descriptions.length) {
                case 1:
                    return descriptions[0]

                case 2:
                    return descriptions[0] + " or " + descriptions[1]

                default:
                    return (
                        descriptions.slice(0, -1).join(", ") +
                        ", or " +
                        descriptions[descriptions.length - 1]
                    )
            }
        }

        function describeFound(found) {
            return found ? '"' + literalEscape(found) + '"' : "end of input"
        }

        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found."
    }
}

function peg$parse(input, options) {
    options = options !== undefined ? options : {}

    const peg$FAILED = {}
    const peg$source = options.grammarSource

    const peg$startRuleFunctions = {
        vmLine: peg$parsevmLine,
        VmParsedStack: peg$parseVmParsedStack,
    }
    let peg$startRuleFunction = peg$parsevmLine

    const peg$c0 = "stack: "
    const peg$c1 = "code cell hash:"
    const peg$c2 = "offset:"
    const peg$c3 = "execute "
    const peg$c4 = "changing gas limit to "
    const peg$c5 = "gas remaining: "
    const peg$c6 = "handling exception code "
    const peg$c7 = ": "
    const peg$c8 = "default exception handler, terminating vm with exit code "
    const peg$c9 = "final c5:"
    const peg$c10 = "stack"
    const peg$c11 = "["
    const peg$c12 = "]"
    const peg$c13 = "()"
    const peg$c14 = "(null)"
    const peg$c15 = "NaN"
    const peg$c16 = "("
    const peg$c17 = ")"
    const peg$c18 = "C{"
    const peg$c19 = "}"
    const peg$c20 = "Cont{"
    const peg$c21 = "BC{"
    const peg$c22 = "???"
    const peg$c23 = "CS{"
    const peg$c24 = "Cell{"
    const peg$c25 = ";"
    const peg$c26 = "bits:"
    const peg$c27 = ".."
    const peg$c28 = "refs:"
    const peg$c29 = "-"

    const peg$r0 = /^[^\r\n]/
    const peg$r1 = /^[A-Za-z_0-9]/
    const peg$r2 = /^[0-9]/
    const peg$r3 = /^[0-9a-fA-F]/
    const peg$r4 = /^[ \t\r\n]/

    const peg$e0 = peg$literalExpectation("stack: ", false)
    const peg$e1 = peg$classExpectation(["\r", "\n"], true, false, false)
    const peg$e2 = peg$literalExpectation("code cell hash:", false)
    const peg$e3 = peg$literalExpectation("offset:", false)
    const peg$e4 = peg$literalExpectation("execute ", false)
    const peg$e5 = peg$literalExpectation("changing gas limit to ", false)
    const peg$e6 = peg$literalExpectation("gas remaining: ", false)
    const peg$e7 = peg$literalExpectation("handling exception code ", false)
    const peg$e8 = peg$literalExpectation(": ", false)
    const peg$e9 = peg$literalExpectation(
        "default exception handler, terminating vm with exit code ",
        false,
    )
    const peg$e10 = peg$literalExpectation("final c5:", false)
    const peg$e11 = peg$literalExpectation("stack", false)
    const peg$e12 = peg$literalExpectation("[", false)
    const peg$e13 = peg$literalExpectation("]", false)
    const peg$e14 = peg$literalExpectation("()", false)
    const peg$e15 = peg$literalExpectation("(null)", false)
    const peg$e16 = peg$literalExpectation("NaN", false)
    const peg$e17 = peg$literalExpectation("(", false)
    const peg$e18 = peg$literalExpectation(")", false)
    const peg$e19 = peg$literalExpectation("C{", false)
    const peg$e20 = peg$literalExpectation("}", false)
    const peg$e21 = peg$literalExpectation("Cont{", false)
    const peg$e22 = peg$classExpectation(
        [["A", "Z"], ["a", "z"], "_", ["0", "9"]],
        false,
        false,
        false,
    )
    const peg$e23 = peg$literalExpectation("BC{", false)
    const peg$e24 = peg$literalExpectation("???", false)
    const peg$e25 = peg$literalExpectation("CS{", false)
    const peg$e26 = peg$literalExpectation("Cell{", false)
    const peg$e27 = peg$literalExpectation(";", false)
    const peg$e28 = peg$literalExpectation("bits:", false)
    const peg$e29 = peg$literalExpectation("..", false)
    const peg$e30 = peg$literalExpectation("refs:", false)
    const peg$e31 = peg$literalExpectation("-", false)
    const peg$e32 = peg$classExpectation([["0", "9"]], false, false, false)
    const peg$e33 = peg$classExpectation(
        [
            ["0", "9"],
            ["a", "f"],
            ["A", "F"],
        ],
        false,
        false,
        false,
    )
    const peg$e34 = peg$classExpectation([" ", "\t", "\r", "\n"], false, false, false)

    function peg$f0(stack) {
        return {$: "VmStack", stack}
    }
    function peg$f1(hash, offset) {
        return {$: "VmLoc", hash: hash.trim(), offset}
    }
    function peg$f2(instr) {
        return {$: "VmExecute", instr: instr.trim()}
    }
    function peg$f3(limit) {
        return {$: "VmLimitChanged", limit}
    }
    function peg$f4(gas) {
        return {$: "VmGasRemaining", gas}
    }
    function peg$f5(errno, message) {
        return {$: "VmException", errno, message: message.trim()}
    }
    function peg$f6(errno) {
        return {$: "VmExceptionHandler", errno}
    }
    function peg$f7(value) {
        return {$: "VmFinalC5", value}
    }
    function peg$f8(text) {
        return {$: "VmUnknown", text: text.trim()}
    }
    function peg$f9(values) {
        return {$: "VmParsedStack", values}
    }
    function peg$f10(value) {
        return {$: "VmStackValue", value}
    }
    function peg$f11() {
        return {$: "Null"}
    }
    function peg$f12() {
        return {$: "NaN"}
    }
    function peg$f13(value) {
        return {$: "Integer", value: value}
    }
    function peg$f14(elements) {
        return {$: "Tuple", elements}
    }
    function peg$f15(elements) {
        return {$: "Tuple", elements}
    }
    function peg$f16(value) {
        return {$: "Cell", value}
    }
    function peg$f17(value) {
        return {$: "Continuation", value}
    }
    function peg$f18(value) {
        return {$: "Builder", value}
    }
    function peg$f19() {
        return {$: "Unknown", value: ""}
    }
    function peg$f20(body) {
        return {
            $: "CellSlice",
            body,
        }
    }
    function peg$f21(value, bits, refs) {
        return {value, bits, refs}
    }
    function peg$f22(start, end) {
        return {start, end}
    }
    function peg$f23(start, end) {
        return {start, end}
    }
    function peg$f24(value) {
        return {value}
    }
    function peg$f25(op, digits) {
        return {op: op || undefined, value: digits}
    }
    let peg$currPos = options.peg$currPos | 0
    let peg$savedPos = peg$currPos
    const peg$posDetailsCache = [{line: 1, column: 1}]
    let peg$maxFailPos = peg$currPos
    let peg$maxFailExpected = options.peg$maxFailExpected || []
    let peg$silentFails = options.peg$silentFails | 0

    let peg$result

    if (options.startRule) {
        if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + '".')
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule]
    }

    function text() {
        return input.substring(peg$savedPos, peg$currPos)
    }

    function offset() {
        return peg$savedPos
    }

    function range() {
        return {
            source: peg$source,
            start: peg$savedPos,
            end: peg$currPos,
        }
    }

    function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos)
    }

    function expected(description, location) {
        location =
            location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos)

        throw peg$buildStructuredError(
            [peg$otherExpectation(description)],
            input.substring(peg$savedPos, peg$currPos),
            location,
        )
    }

    function error(message, location) {
        location =
            location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos)

        throw peg$buildSimpleError(message, location)
    }

    function peg$getUnicode(pos = peg$currPos) {
        const cp = input.codePointAt(pos)
        if (cp === undefined) {
            return ""
        }
        return String.fromCodePoint(cp)
    }

    function peg$literalExpectation(text, ignoreCase) {
        return {type: "literal", text, ignoreCase}
    }

    function peg$classExpectation(parts, inverted, ignoreCase, unicode) {
        return {type: "class", parts, inverted, ignoreCase, unicode}
    }

    function peg$anyExpectation() {
        return {type: "any"}
    }

    function peg$endExpectation() {
        return {type: "end"}
    }

    function peg$otherExpectation(description) {
        return {type: "other", description}
    }

    function peg$computePosDetails(pos) {
        let details = peg$posDetailsCache[pos]
        let p

        if (details) {
            return details
        } else {
            if (pos >= peg$posDetailsCache.length) {
                p = peg$posDetailsCache.length - 1
            } else {
                p = pos
                while (!peg$posDetailsCache[--p]) {}
            }

            details = peg$posDetailsCache[p]
            details = {
                line: details.line,
                column: details.column,
            }

            while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                    details.line++
                    details.column = 1
                } else {
                    details.column++
                }

                p++
            }

            peg$posDetailsCache[pos] = details

            return details
        }
    }

    function peg$computeLocation(startPos, endPos, offset) {
        const startPosDetails = peg$computePosDetails(startPos)
        const endPosDetails = peg$computePosDetails(endPos)

        const res = {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column,
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column,
            },
        }
        if (offset && peg$source && typeof peg$source.offset === "function") {
            res.start = peg$source.offset(res.start)
            res.end = peg$source.offset(res.end)
        }
        return res
    }

    function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) {
            return
        }

        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos
            peg$maxFailExpected = []
        }

        peg$maxFailExpected.push(expected)
    }

    function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location)
    }

    function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(
            peg$SyntaxError.buildMessage(expected, found),
            expected,
            found,
            location,
        )
    }

    function peg$parsevmLine() {
        let s0

        s0 = peg$parseVmLoc()
        if (s0 === peg$FAILED) {
            s0 = peg$parseVmStack()
            if (s0 === peg$FAILED) {
                s0 = peg$parseVmExecute()
                if (s0 === peg$FAILED) {
                    s0 = peg$parseVmLimitChanged()
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseVmGasRemaining()
                        if (s0 === peg$FAILED) {
                            s0 = peg$parseVmException()
                            if (s0 === peg$FAILED) {
                                s0 = peg$parseVmExceptionHandler()
                                if (s0 === peg$FAILED) {
                                    s0 = peg$parseVmFinalC5()
                                    if (s0 === peg$FAILED) {
                                        s0 = peg$parseVmUnknown()
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        return s0
    }

    function peg$parseVmStack() {
        let s0, s1, s2, s3, s4

        s0 = peg$currPos
        if (input.substr(peg$currPos, 7) === peg$c0) {
            s1 = peg$c0
            peg$currPos += 7
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e0)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos
            s3 = []
            s4 = input.charAt(peg$currPos)
            if (peg$r0.test(s4)) {
                peg$currPos++
            } else {
                s4 = peg$FAILED
                if (peg$silentFails === 0) {
                    peg$fail(peg$e1)
                }
            }
            while (s4 !== peg$FAILED) {
                s3.push(s4)
                s4 = input.charAt(peg$currPos)
                if (peg$r0.test(s4)) {
                    peg$currPos++
                } else {
                    s4 = peg$FAILED
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e1)
                    }
                }
            }
            s2 = input.substring(s2, peg$currPos)
            peg$savedPos = s0
            s0 = peg$f0(s2)
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseVmLoc() {
        let s0, s1, s2, s3, s4, s5, s6, s7

        s0 = peg$currPos
        if (input.substr(peg$currPos, 15) === peg$c1) {
            s1 = peg$c1
            peg$currPos += 15
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e2)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = []
            s3 = peg$parsespace()
            while (s3 !== peg$FAILED) {
                s2.push(s3)
                s3 = peg$parsespace()
            }
            s3 = peg$parsehex()
            s4 = []
            s5 = peg$parsespace()
            if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                    s4.push(s5)
                    s5 = peg$parsespace()
                }
            } else {
                s4 = peg$FAILED
            }
            if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c2) {
                    s5 = peg$c2
                    peg$currPos += 7
                } else {
                    s5 = peg$FAILED
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e3)
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = []
                    s7 = peg$parsespace()
                    while (s7 !== peg$FAILED) {
                        s6.push(s7)
                        s7 = peg$parsespace()
                    }
                    s7 = peg$parsenumber()
                    if (s7 !== peg$FAILED) {
                        peg$savedPos = s0
                        s0 = peg$f1(s3, s7)
                    } else {
                        peg$currPos = s0
                        s0 = peg$FAILED
                    }
                } else {
                    peg$currPos = s0
                    s0 = peg$FAILED
                }
            } else {
                peg$currPos = s0
                s0 = peg$FAILED
            }
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseVmExecute() {
        let s0, s1, s2, s3, s4

        s0 = peg$currPos
        if (input.substr(peg$currPos, 8) === peg$c3) {
            s1 = peg$c3
            peg$currPos += 8
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e4)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos
            s3 = []
            s4 = input.charAt(peg$currPos)
            if (peg$r0.test(s4)) {
                peg$currPos++
            } else {
                s4 = peg$FAILED
                if (peg$silentFails === 0) {
                    peg$fail(peg$e1)
                }
            }
            while (s4 !== peg$FAILED) {
                s3.push(s4)
                s4 = input.charAt(peg$currPos)
                if (peg$r0.test(s4)) {
                    peg$currPos++
                } else {
                    s4 = peg$FAILED
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e1)
                    }
                }
            }
            s2 = input.substring(s2, peg$currPos)
            peg$savedPos = s0
            s0 = peg$f2(s2)
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseVmLimitChanged() {
        let s0, s1, s2

        s0 = peg$currPos
        if (input.substr(peg$currPos, 22) === peg$c4) {
            s1 = peg$c4
            peg$currPos += 22
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e5)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsenumber()
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0
                s0 = peg$f3(s2)
            } else {
                peg$currPos = s0
                s0 = peg$FAILED
            }
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseVmGasRemaining() {
        let s0, s1, s2

        s0 = peg$currPos
        if (input.substr(peg$currPos, 15) === peg$c5) {
            s1 = peg$c5
            peg$currPos += 15
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e6)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsenumber()
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0
                s0 = peg$f4(s2)
            } else {
                peg$currPos = s0
                s0 = peg$FAILED
            }
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseVmException() {
        let s0, s1, s2, s3, s4, s5, s6

        s0 = peg$currPos
        if (input.substr(peg$currPos, 24) === peg$c6) {
            s1 = peg$c6
            peg$currPos += 24
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e7)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsenumber()
            if (s2 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c7) {
                    s3 = peg$c7
                    peg$currPos += 2
                } else {
                    s3 = peg$FAILED
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e8)
                    }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$currPos
                    s5 = []
                    s6 = input.charAt(peg$currPos)
                    if (peg$r0.test(s6)) {
                        peg$currPos++
                    } else {
                        s6 = peg$FAILED
                        if (peg$silentFails === 0) {
                            peg$fail(peg$e1)
                        }
                    }
                    while (s6 !== peg$FAILED) {
                        s5.push(s6)
                        s6 = input.charAt(peg$currPos)
                        if (peg$r0.test(s6)) {
                            peg$currPos++
                        } else {
                            s6 = peg$FAILED
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e1)
                            }
                        }
                    }
                    s4 = input.substring(s4, peg$currPos)
                    peg$savedPos = s0
                    s0 = peg$f5(s2, s4)
                } else {
                    peg$currPos = s0
                    s0 = peg$FAILED
                }
            } else {
                peg$currPos = s0
                s0 = peg$FAILED
            }
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseVmExceptionHandler() {
        let s0, s1, s2

        s0 = peg$currPos
        if (input.substr(peg$currPos, 57) === peg$c8) {
            s1 = peg$c8
            peg$currPos += 57
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e9)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsenumber()
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0
                s0 = peg$f6(s2)
            } else {
                peg$currPos = s0
                s0 = peg$FAILED
            }
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseVmFinalC5() {
        let s0, s1, s2

        s0 = peg$currPos
        if (input.substr(peg$currPos, 9) === peg$c9) {
            s1 = peg$c9
            peg$currPos += 9
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e10)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseCell()
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0
                s0 = peg$f7(s2)
            } else {
                peg$currPos = s0
                s0 = peg$FAILED
            }
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseVmUnknown() {
        let s0, s1, s2, s3, s4

        s0 = peg$currPos
        s1 = peg$currPos
        peg$silentFails++
        if (input.substr(peg$currPos, 5) === peg$c10) {
            s2 = peg$c10
            peg$currPos += 5
        } else {
            s2 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e11)
            }
        }
        if (s2 === peg$FAILED) {
            if (input.substr(peg$currPos, 15) === peg$c1) {
                s2 = peg$c1
                peg$currPos += 15
            } else {
                s2 = peg$FAILED
                if (peg$silentFails === 0) {
                    peg$fail(peg$e2)
                }
            }
            if (s2 === peg$FAILED) {
                if (input.substr(peg$currPos, 8) === peg$c3) {
                    s2 = peg$c3
                    peg$currPos += 8
                } else {
                    s2 = peg$FAILED
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e4)
                    }
                }
                if (s2 === peg$FAILED) {
                    if (input.substr(peg$currPos, 22) === peg$c4) {
                        s2 = peg$c4
                        peg$currPos += 22
                    } else {
                        s2 = peg$FAILED
                        if (peg$silentFails === 0) {
                            peg$fail(peg$e5)
                        }
                    }
                    if (s2 === peg$FAILED) {
                        if (input.substr(peg$currPos, 15) === peg$c5) {
                            s2 = peg$c5
                            peg$currPos += 15
                        } else {
                            s2 = peg$FAILED
                            if (peg$silentFails === 0) {
                                peg$fail(peg$e6)
                            }
                        }
                        if (s2 === peg$FAILED) {
                            if (input.substr(peg$currPos, 24) === peg$c6) {
                                s2 = peg$c6
                                peg$currPos += 24
                            } else {
                                s2 = peg$FAILED
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$e7)
                                }
                            }
                            if (s2 === peg$FAILED) {
                                if (input.substr(peg$currPos, 57) === peg$c8) {
                                    s2 = peg$c8
                                    peg$currPos += 57
                                } else {
                                    s2 = peg$FAILED
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$e9)
                                    }
                                }
                                if (s2 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 9) === peg$c9) {
                                        s2 = peg$c9
                                        peg$currPos += 9
                                    } else {
                                        s2 = peg$FAILED
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$e10)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        peg$silentFails--
        if (s2 === peg$FAILED) {
            s1 = undefined
        } else {
            peg$currPos = s1
            s1 = peg$FAILED
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos
            s3 = []
            s4 = input.charAt(peg$currPos)
            if (peg$r0.test(s4)) {
                peg$currPos++
            } else {
                s4 = peg$FAILED
                if (peg$silentFails === 0) {
                    peg$fail(peg$e1)
                }
            }
            while (s4 !== peg$FAILED) {
                s3.push(s4)
                s4 = input.charAt(peg$currPos)
                if (peg$r0.test(s4)) {
                    peg$currPos++
                } else {
                    s4 = peg$FAILED
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e1)
                    }
                }
            }
            s2 = input.substring(s2, peg$currPos)
            peg$savedPos = s0
            s0 = peg$f8(s2)
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseVmParsedStack() {
        let s0, s1, s2, s3, s4

        s0 = peg$currPos
        if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c11
            peg$currPos++
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e12)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = []
            s3 = peg$parsespace()
            while (s3 !== peg$FAILED) {
                s2.push(s3)
                s3 = peg$parsespace()
            }
            s3 = []
            s4 = peg$parseVmStackValue()
            while (s4 !== peg$FAILED) {
                s3.push(s4)
                s4 = peg$parseVmStackValue()
            }
            if (input.charCodeAt(peg$currPos) === 93) {
                s4 = peg$c12
                peg$currPos++
            } else {
                s4 = peg$FAILED
                if (peg$silentFails === 0) {
                    peg$fail(peg$e13)
                }
            }
            if (s4 !== peg$FAILED) {
                peg$savedPos = s0
                s0 = peg$f9(s3)
            } else {
                peg$currPos = s0
                s0 = peg$FAILED
            }
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseVmStackValue() {
        let s0, s1, s2, s3, s4

        s0 = peg$currPos
        s1 = []
        s2 = peg$parsespace()
        while (s2 !== peg$FAILED) {
            s1.push(s2)
            s2 = peg$parsespace()
        }
        s2 = peg$parseNull()
        if (s2 === peg$FAILED) {
            s2 = peg$parseNaN()
            if (s2 === peg$FAILED) {
                s2 = peg$parseInteger()
                if (s2 === peg$FAILED) {
                    s2 = peg$parseTuple()
                    if (s2 === peg$FAILED) {
                        s2 = peg$parseTupleParen()
                        if (s2 === peg$FAILED) {
                            s2 = peg$parseCell()
                            if (s2 === peg$FAILED) {
                                s2 = peg$parseContinuation()
                                if (s2 === peg$FAILED) {
                                    s2 = peg$parseBuilder()
                                    if (s2 === peg$FAILED) {
                                        s2 = peg$parseCellSlice()
                                        if (s2 === peg$FAILED) {
                                            s2 = peg$parseUnknown()
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (s2 !== peg$FAILED) {
            s3 = []
            s4 = peg$parsespace()
            while (s4 !== peg$FAILED) {
                s3.push(s4)
                s4 = peg$parsespace()
            }
            peg$savedPos = s0
            s0 = peg$f10(s2)
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseNull() {
        let s0, s1

        s0 = peg$currPos
        if (input.substr(peg$currPos, 2) === peg$c13) {
            s1 = peg$c13
            peg$currPos += 2
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e14)
            }
        }
        if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 6) === peg$c14) {
                s1 = peg$c14
                peg$currPos += 6
            } else {
                s1 = peg$FAILED
                if (peg$silentFails === 0) {
                    peg$fail(peg$e15)
                }
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0
            s1 = peg$f11()
        }
        s0 = s1

        return s0
    }

    function peg$parseNaN() {
        let s0, s1

        s0 = peg$currPos
        if (input.substr(peg$currPos, 3) === peg$c15) {
            s1 = peg$c15
            peg$currPos += 3
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e16)
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0
            s1 = peg$f12()
        }
        s0 = s1

        return s0
    }

    function peg$parseInteger() {
        let s0, s1

        s0 = peg$currPos
        s1 = peg$parsenumber()
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0
            s1 = peg$f13(s1)
        }
        s0 = s1

        return s0
    }

    function peg$parseTuple() {
        let s0, s1, s2, s3, s4

        s0 = peg$currPos
        if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c11
            peg$currPos++
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e12)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = []
            s3 = peg$parsespace()
            while (s3 !== peg$FAILED) {
                s2.push(s3)
                s3 = peg$parsespace()
            }
            s3 = []
            s4 = peg$parseVmStackValue()
            while (s4 !== peg$FAILED) {
                s3.push(s4)
                s4 = peg$parseVmStackValue()
            }
            if (input.charCodeAt(peg$currPos) === 93) {
                s4 = peg$c12
                peg$currPos++
            } else {
                s4 = peg$FAILED
                if (peg$silentFails === 0) {
                    peg$fail(peg$e13)
                }
            }
            if (s4 !== peg$FAILED) {
                peg$savedPos = s0
                s0 = peg$f14(s3)
            } else {
                peg$currPos = s0
                s0 = peg$FAILED
            }
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseTupleParen() {
        let s0, s1, s2, s3, s4

        s0 = peg$currPos
        if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c16
            peg$currPos++
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e17)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = []
            s3 = peg$parsespace()
            while (s3 !== peg$FAILED) {
                s2.push(s3)
                s3 = peg$parsespace()
            }
            s3 = []
            s4 = peg$parseVmStackValue()
            while (s4 !== peg$FAILED) {
                s3.push(s4)
                s4 = peg$parseVmStackValue()
            }
            if (input.charCodeAt(peg$currPos) === 41) {
                s4 = peg$c17
                peg$currPos++
            } else {
                s4 = peg$FAILED
                if (peg$silentFails === 0) {
                    peg$fail(peg$e18)
                }
            }
            if (s4 !== peg$FAILED) {
                peg$savedPos = s0
                s0 = peg$f15(s3)
            } else {
                peg$currPos = s0
                s0 = peg$FAILED
            }
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseCell() {
        let s0, s1, s2, s3

        s0 = peg$currPos
        if (input.substr(peg$currPos, 2) === peg$c18) {
            s1 = peg$c18
            peg$currPos += 2
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e19)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsehex()
            if (input.charCodeAt(peg$currPos) === 125) {
                s3 = peg$c19
                peg$currPos++
            } else {
                s3 = peg$FAILED
                if (peg$silentFails === 0) {
                    peg$fail(peg$e20)
                }
            }
            if (s3 !== peg$FAILED) {
                peg$savedPos = s0
                s0 = peg$f16(s2)
            } else {
                peg$currPos = s0
                s0 = peg$FAILED
            }
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseContinuation() {
        let s0, s1, s2, s3, s4

        s0 = peg$currPos
        if (input.substr(peg$currPos, 5) === peg$c20) {
            s1 = peg$c20
            peg$currPos += 5
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e21)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos
            s3 = []
            s4 = input.charAt(peg$currPos)
            if (peg$r1.test(s4)) {
                peg$currPos++
            } else {
                s4 = peg$FAILED
                if (peg$silentFails === 0) {
                    peg$fail(peg$e22)
                }
            }
            while (s4 !== peg$FAILED) {
                s3.push(s4)
                s4 = input.charAt(peg$currPos)
                if (peg$r1.test(s4)) {
                    peg$currPos++
                } else {
                    s4 = peg$FAILED
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e22)
                    }
                }
            }
            s2 = input.substring(s2, peg$currPos)
            if (input.charCodeAt(peg$currPos) === 125) {
                s3 = peg$c19
                peg$currPos++
            } else {
                s3 = peg$FAILED
                if (peg$silentFails === 0) {
                    peg$fail(peg$e20)
                }
            }
            if (s3 !== peg$FAILED) {
                peg$savedPos = s0
                s0 = peg$f17(s2)
            } else {
                peg$currPos = s0
                s0 = peg$FAILED
            }
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseBuilder() {
        let s0, s1, s2, s3

        s0 = peg$currPos
        if (input.substr(peg$currPos, 3) === peg$c21) {
            s1 = peg$c21
            peg$currPos += 3
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e23)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsehex()
            if (input.charCodeAt(peg$currPos) === 125) {
                s3 = peg$c19
                peg$currPos++
            } else {
                s3 = peg$FAILED
                if (peg$silentFails === 0) {
                    peg$fail(peg$e20)
                }
            }
            if (s3 !== peg$FAILED) {
                peg$savedPos = s0
                s0 = peg$f18(s2)
            } else {
                peg$currPos = s0
                s0 = peg$FAILED
            }
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseUnknown() {
        let s0, s1

        s0 = peg$currPos
        if (input.substr(peg$currPos, 3) === peg$c22) {
            s1 = peg$c22
            peg$currPos += 3
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e24)
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0
            s1 = peg$f19()
        }
        s0 = s1

        return s0
    }

    function peg$parseCellSlice() {
        let s0, s1, s2, s3

        s0 = peg$currPos
        if (input.substr(peg$currPos, 3) === peg$c23) {
            s1 = peg$c23
            peg$currPos += 3
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e25)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseCellSliceBody()
            if (s2 === peg$FAILED) {
                s2 = peg$parseCellSliceShortBody()
            }
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                    s3 = peg$c19
                    peg$currPos++
                } else {
                    s3 = peg$FAILED
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e20)
                    }
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0
                    s0 = peg$f20(s2)
                } else {
                    peg$currPos = s0
                    s0 = peg$FAILED
                }
            } else {
                peg$currPos = s0
                s0 = peg$FAILED
            }
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseCellSliceBody() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8

        s0 = peg$currPos
        if (input.substr(peg$currPos, 5) === peg$c24) {
            s1 = peg$c24
            peg$currPos += 5
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e26)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsehex()
            if (input.charCodeAt(peg$currPos) === 125) {
                s3 = peg$c19
                peg$currPos++
            } else {
                s3 = peg$FAILED
                if (peg$silentFails === 0) {
                    peg$fail(peg$e20)
                }
            }
            if (s3 !== peg$FAILED) {
                s4 = []
                s5 = peg$parsespace()
                while (s5 !== peg$FAILED) {
                    s4.push(s5)
                    s5 = peg$parsespace()
                }
                s5 = peg$parseCellSliceBits()
                if (s5 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 59) {
                        s6 = peg$c25
                        peg$currPos++
                    } else {
                        s6 = peg$FAILED
                        if (peg$silentFails === 0) {
                            peg$fail(peg$e27)
                        }
                    }
                    if (s6 !== peg$FAILED) {
                        s7 = []
                        s8 = peg$parsespace()
                        while (s8 !== peg$FAILED) {
                            s7.push(s8)
                            s8 = peg$parsespace()
                        }
                        s8 = peg$parseCellSliceRefs()
                        if (s8 !== peg$FAILED) {
                            peg$savedPos = s0
                            s0 = peg$f21(s2, s5, s8)
                        } else {
                            peg$currPos = s0
                            s0 = peg$FAILED
                        }
                    } else {
                        peg$currPos = s0
                        s0 = peg$FAILED
                    }
                } else {
                    peg$currPos = s0
                    s0 = peg$FAILED
                }
            } else {
                peg$currPos = s0
                s0 = peg$FAILED
            }
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseCellSliceBits() {
        let s0, s1, s2, s3, s4, s5

        s0 = peg$currPos
        if (input.substr(peg$currPos, 5) === peg$c26) {
            s1 = peg$c26
            peg$currPos += 5
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e28)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = []
            s3 = peg$parsespace()
            while (s3 !== peg$FAILED) {
                s2.push(s3)
                s3 = peg$parsespace()
            }
            s3 = peg$parsenumber()
            if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c27) {
                    s4 = peg$c27
                    peg$currPos += 2
                } else {
                    s4 = peg$FAILED
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e29)
                    }
                }
                if (s4 !== peg$FAILED) {
                    s5 = peg$parsenumber()
                    if (s5 !== peg$FAILED) {
                        peg$savedPos = s0
                        s0 = peg$f22(s3, s5)
                    } else {
                        peg$currPos = s0
                        s0 = peg$FAILED
                    }
                } else {
                    peg$currPos = s0
                    s0 = peg$FAILED
                }
            } else {
                peg$currPos = s0
                s0 = peg$FAILED
            }
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseCellSliceRefs() {
        let s0, s1, s2, s3, s4, s5

        s0 = peg$currPos
        if (input.substr(peg$currPos, 5) === peg$c28) {
            s1 = peg$c28
            peg$currPos += 5
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e30)
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = []
            s3 = peg$parsespace()
            while (s3 !== peg$FAILED) {
                s2.push(s3)
                s3 = peg$parsespace()
            }
            s3 = peg$parsenumber()
            if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c27) {
                    s4 = peg$c27
                    peg$currPos += 2
                } else {
                    s4 = peg$FAILED
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e29)
                    }
                }
                if (s4 !== peg$FAILED) {
                    s5 = peg$parsenumber()
                    if (s5 !== peg$FAILED) {
                        peg$savedPos = s0
                        s0 = peg$f23(s3, s5)
                    } else {
                        peg$currPos = s0
                        s0 = peg$FAILED
                    }
                } else {
                    peg$currPos = s0
                    s0 = peg$FAILED
                }
            } else {
                peg$currPos = s0
                s0 = peg$FAILED
            }
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parseCellSliceShortBody() {
        let s0, s1

        s0 = peg$currPos
        s1 = peg$parsehex()
        peg$savedPos = s0
        s1 = peg$f24(s1)
        s0 = s1

        return s0
    }

    function peg$parsenumber() {
        let s0, s1, s2, s3, s4

        s0 = peg$currPos
        if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c29
            peg$currPos++
        } else {
            s1 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e31)
            }
        }
        if (s1 === peg$FAILED) {
            s1 = null
        }
        s2 = peg$currPos
        s3 = []
        s4 = input.charAt(peg$currPos)
        if (peg$r2.test(s4)) {
            peg$currPos++
        } else {
            s4 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e32)
            }
        }
        if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
                s3.push(s4)
                s4 = input.charAt(peg$currPos)
                if (peg$r2.test(s4)) {
                    peg$currPos++
                } else {
                    s4 = peg$FAILED
                    if (peg$silentFails === 0) {
                        peg$fail(peg$e32)
                    }
                }
            }
        } else {
            s3 = peg$FAILED
        }
        if (s3 !== peg$FAILED) {
            s2 = input.substring(s2, peg$currPos)
        } else {
            s2 = s3
        }
        if (s2 !== peg$FAILED) {
            peg$savedPos = s0
            s0 = peg$f25(s1, s2)
        } else {
            peg$currPos = s0
            s0 = peg$FAILED
        }

        return s0
    }

    function peg$parsehex() {
        let s0, s1, s2

        s0 = peg$currPos
        s1 = []
        s2 = input.charAt(peg$currPos)
        if (peg$r3.test(s2)) {
            peg$currPos++
        } else {
            s2 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e33)
            }
        }
        while (s2 !== peg$FAILED) {
            s1.push(s2)
            s2 = input.charAt(peg$currPos)
            if (peg$r3.test(s2)) {
                peg$currPos++
            } else {
                s2 = peg$FAILED
                if (peg$silentFails === 0) {
                    peg$fail(peg$e33)
                }
            }
        }
        s0 = input.substring(s0, peg$currPos)

        return s0
    }

    function peg$parsespace() {
        let s0

        s0 = input.charAt(peg$currPos)
        if (peg$r4.test(s0)) {
            peg$currPos++
        } else {
            s0 = peg$FAILED
            if (peg$silentFails === 0) {
                peg$fail(peg$e34)
            }
        }

        return s0
    }

    peg$result = peg$startRuleFunction()

    const peg$success = peg$result !== peg$FAILED && peg$currPos === input.length
    function peg$throw() {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation())
        }

        throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input.length ? peg$getUnicode(peg$maxFailPos) : null,
            peg$maxFailPos < input.length
                ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
                : peg$computeLocation(peg$maxFailPos, peg$maxFailPos),
        )
    }
    if (options.peg$library) {
        return /** @type {any} */ {
            peg$result,
            peg$currPos,
            peg$FAILED,
            peg$maxFailExpected,
            peg$maxFailPos,
            peg$success,
            peg$throw: peg$success ? undefined : peg$throw,
        }
    }
    if (peg$success) {
        return peg$result
    } else {
        peg$throw()
    }
}

const peg$allowedStartRules = ["vmLine", "VmParsedStack"]

export {peg$allowedStartRules as StartRules, peg$SyntaxError as SyntaxError, peg$parse as parse}
